{
  "openapi": "3.0.2",
  "info": {
    "title": "HashiCorp Vault API",
    "description": "HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.",
    "version": "1.13.0",
    "license": {
      "name": "Mozilla Public License 2.0",
      "url": "https://www.mozilla.org/en-US/MPL/2.0"
    }
  },
  "paths": {
    "/audit": {
      "description": "List the currently enabled audit backends.",
      "x-vault-sudo": true,
      "get": {
        "summary": "List the enabled audit devices.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/audit-hash/{path}": {
      "description": "The hash of the given string via the given audit backend",
      "parameters": [
        {
          "name": "path",
          "description": "The name of the backend. Cannot be delimited. Example: \"mysql\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuditHashRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuditHashResponse"
                }
              }
            }
          }
        }
      }
    },
    "/audit/{path}": {
      "description": "Enable or disable audit backends.",
      "parameters": [
        {
          "name": "path",
          "description": "The name of the backend. Cannot be delimited. Example: \"mysql\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "post": {
        "summary": "Enable a new audit device at the supplied path.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuditRequest"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Disable the audit device at the given path.",
        "responses": {
          "204": {
            "description": "OK"
          }
        }
      }
    },
    "/auth": {
      "description": "List the currently enabled credential backends.",
      "get": {
        "summary": "List the currently enabled credential backends.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/auth/{path}": {
      "description": "Enable a new credential backend with a name.",
      "parameters": [
        {
          "name": "path",
          "description": "The path to mount to. Cannot be delimited. Example: \"user\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Read the configuration of the auth engine at the given path.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Enables a new auth method.",
        "description": "After enabling, the auth method can be accessed and configured via the auth path specified as part of the URL. This auth path will be nested under the auth prefix.\n\nFor example, enable the \"foo\" auth method will make it accessible at /auth/foo.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Disable the auth method at the given auth path",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/auth/{path}/tune": {
      "description": "Tune the configuration parameters for an auth path.",
      "parameters": [
        {
          "name": "path",
          "description": "Tune the configuration parameters for an auth path.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Reads the given auth path's configuration.",
        "description": "This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]/tune`.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Tune configuration parameters for a given auth path.",
        "description": "This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]/tune`.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthTuneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/capabilities": {
      "description": "Fetches the capabilities of the given token on the given path.",
      "post": {
        "summary": "Fetches the capabilities of the given token on the given path.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CapabilitiesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/capabilities-accessor": {
      "description": "Fetches the capabilities of the token associated with the given token, on the given path.",
      "post": {
        "summary": "Fetches the capabilities of the token associated with the given token, on the given path.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CapabilitiesAccessorRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/capabilities-self": {
      "description": "Fetches the capabilities of the given token on the given path.",
      "post": {
        "summary": "Fetches the capabilities of the given token on the given path.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CapabilitiesSelfRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/config/auditing/request-headers": {
      "description": "Lists the headers configured to be audited.",
      "x-vault-sudo": true,
      "get": {
        "summary": "List the request headers that are configured to be audited.",
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConfigAuditingRequestHeadersResponse"
                }
              }
            }
          }
        }
      }
    },
    "/config/auditing/request-headers/{header}": {
      "description": "Configures the headers sent to the audit logs.",
      "parameters": [
        {
          "name": "header",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "List the information for the given request header.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Enable auditing of a header.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConfigAuditingRequestHeadersRequest"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Disable auditing of the given request header.",
        "responses": {
          "204": {
            "description": "OK"
          }
        }
      }
    },
    "/config/cors": {
      "description": "This path responds to the following HTTP methods. GET / Returns the configuration of the CORS setting. POST / Sets the comma-separated list of origins that can make cross-origin requests. DELETE / Clears the CORS configuration and disables acceptance of CORS requests.",
      "x-vault-sudo": true,
      "get": {
        "summary": "Return the current CORS settings.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the CORS settings.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConfigCorsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Remove any CORS settings.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/config/reload/{subsystem}": {
      "parameters": [
        {
          "name": "subsystem",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Reload the given subsystem",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/config/state/sanitized": {
      "get": {
        "summary": "Return a sanitized version of the Vault server configuration.",
        "description": "The sanitized output strips configuration values in the storage, HA storage, and seals stanzas, which may contain sensitive values such as API tokens. It also removes any token or secret fields in other stanzas, such as the circonus_api_token from telemetry.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/config/ui/headers/": {
      "description": "This path responds to the following HTTP methods. GET /<header> Returns the header value. POST /<header> Sets the header value for the UI. DELETE /<header> Clears the header value for UI. LIST / List the headers configured for the UI.",
      "x-vault-sudo": true,
      "get": {
        "summary": "Return a list of configured UI headers.",
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/config/ui/headers/{header}": {
      "description": "This path responds to the following HTTP methods. GET /<header> Returns the header value. POST /<header> Sets the header value for the UI. DELETE /<header> Clears the header value for UI. LIST / List the headers configured for the UI.",
      "parameters": [
        {
          "name": "header",
          "description": "The name of the header.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Return the given UI header's configuration",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Configure the values to be returned for the UI header.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ConfigUiHeadersRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Remove a UI header.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/experiments": {
      "description": "Returns information about Vault's experimental features. Should NOT be used in production.",
      "get": {
        "summary": "Returns the available and enabled experiments",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/generate-root": {
      "description": "Reads, generates, or deletes a root token regeneration process.",
      "get": {
        "summary": "Read the configuration and progress of the current root generation attempt.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Initializes a new root generation attempt.",
        "description": "Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GenerateRootRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Cancels any in-progress root generation attempt.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/generate-root/attempt": {
      "description": "Reads, generates, or deletes a root token regeneration process.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Read the configuration and progress of the current root generation attempt.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Initializes a new root generation attempt.",
        "description": "Only a single root generation attempt can take place at a time. One (and only one) of otp or pgp_key are required.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GenerateRootAttemptRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Cancels any in-progress root generation attempt.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/generate-root/update": {
      "description": "Reads, generates, or deletes a root token regeneration process.",
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Enter a single unseal key share to progress the root generation attempt.",
        "description": "If the threshold number of unseal key shares is reached, Vault will complete the root generation and issue the new token. Otherwise, this API must be called multiple times until that threshold is met. The attempt nonce must be provided with each call.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GenerateRootUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/ha-status": {
      "description": "Provides information about the nodes in an HA cluster.",
      "get": {
        "summary": "Check the HA status of a Vault cluster",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/health": {
      "description": "Checks the health status of the Vault.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Returns the health status of Vault.",
        "responses": {
          "200": {
            "description": "initialized, unsealed, and active"
          },
          "429": {
            "description": "unsealed and standby"
          },
          "472": {
            "description": "data recovery mode replication secondary and active"
          },
          "501": {
            "description": "not initialized"
          },
          "503": {
            "description": "sealed"
          }
        }
      }
    },
    "/host-info": {
      "description": "Information about the host instance that this Vault server is running on.",
      "get": {
        "summary": "Information about the host instance that this Vault server is running on.",
        "description": "Information about the host instance that this Vault server is running on.\n\t\tThe information that gets collected includes host hardware information, and CPU,\n\t\tdisk, and memory utilization",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/in-flight-req": {
      "get": {
        "summary": "reports in-flight requests",
        "description": "This path responds to the following HTTP methods.\n\t\tGET /\n\t\t\tReturns a map of in-flight requests.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/init": {
      "description": "Initializes or returns the initialization status of the Vault.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Returns the initialization status of Vault.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Initialize a new Vault.",
        "description": "The Vault must not have been previously initialized. The recovery options, as well as the stored shares option, are only available when using Vault HSM.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InitRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/internal/counters/activity": {
      "description": "Query the historical count of clients.",
      "get": {
        "summary": "Report the client count metrics, for this namespace and all child namespaces.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/internal/counters/activity/export": {
      "description": "Export the historical activity of clients.",
      "get": {
        "summary": "Report the client count metrics, for this namespace and all child namespaces.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/internal/counters/activity/monthly": {
      "description": "Count of active clients so far this month.",
      "get": {
        "summary": "Report the number of clients for this month, for this namespace and all child namespaces.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/internal/counters/config": {
      "description": "Control the collection and reporting of client counts.",
      "get": {
        "summary": "Read the client count tracking configuration.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Enable or disable collection of client count, set retention period, or set default reporting period.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InternalCountersConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/internal/counters/entities": {
      "description": "Count of active entities in this Vault cluster.",
      "get": {
        "summary": "Backwards compatibility is not guaranteed for this API",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/internal/counters/requests": {
      "description": "Currently unsupported. Previously, count of requests seen by this Vault cluster over time.",
      "get": {
        "summary": "Backwards compatibility is not guaranteed for this API",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/internal/counters/tokens": {
      "description": "Count of active tokens in this Vault cluster.",
      "get": {
        "summary": "Backwards compatibility is not guaranteed for this API",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/internal/inspect/router/{tag}": {
      "description": "Information on the entries in each of the trees in the router. Inspectable trees are uuid, accessor, storage, and root.",
      "parameters": [
        {
          "name": "tag",
          "description": "Name of subtree being observed",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Expose the route entry and mount entry tables present in the router",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/internal/specs/openapi": {
      "description": "Generate an OpenAPI 3 document of all mounted paths.",
      "parameters": [
        {
          "name": "generic_mount_paths",
          "description": "Use generic mount paths",
          "in": "query",
          "schema": {
            "type": "boolean",
            "default": false
          }
        }
      ],
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Generate an OpenAPI 3 document of all mounted paths.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Generate an OpenAPI 3 document of all mounted paths.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/InternalSpecsOpenapiRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/internal/ui/feature-flags": {
      "description": "Enabled feature flags. Internal API; its location, inputs, and outputs may change.",
      "get": {
        "summary": "Lists enabled feature flags.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/internal/ui/mounts": {
      "description": "Information about mounts returned according to their tuned visibility. Internal API; its location, inputs, and outputs may change.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Lists all enabled and visible auth and secrets mounts.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/internal/ui/mounts/{path}": {
      "description": "Information about mounts returned according to their tuned visibility. Internal API; its location, inputs, and outputs may change.",
      "parameters": [
        {
          "name": "path",
          "description": "The path of the mount.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Return information about the given mount.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/internal/ui/namespaces": {
      "description": "Information about visible child namespaces. Internal API; its location, inputs, and outputs may change.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Backwards compatibility is not guaranteed for this API",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/internal/ui/resultant-acl": {
      "description": "Information about a token's resultant ACL. Internal API; its location, inputs, and outputs may change.",
      "get": {
        "summary": "Backwards compatibility is not guaranteed for this API",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/key-status": {
      "description": "Provides information about the backend encryption key.",
      "get": {
        "summary": "Provides information about the backend encryption key.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/leader": {
      "description": "Check the high availability status and current leader of Vault",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Returns the high availability status and current leader instance of Vault.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/leases": {
      "description": "List leases associated with this Vault cluster",
      "x-vault-sudo": true,
      "get": {
        "summary": "List leases associated with this Vault cluster",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/leases/count": {
      "description": "Count of leases associated with this Vault cluster",
      "get": {
        "summary": "Count of leases associated with this Vault cluster",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/leases/lookup": {
      "description": "View or list lease metadata.",
      "post": {
        "summary": "Retrieve lease metadata.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LeasesLookupRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/leases/lookup/": {
      "description": "View or list lease metadata.",
      "x-vault-sudo": true,
      "get": {
        "summary": "Returns a list of lease ids.",
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/leases/lookup/{prefix}": {
      "description": "View or list lease metadata.",
      "parameters": [
        {
          "name": "prefix",
          "description": "The path to list leases under. Example: \"aws/creds/deploy\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Returns a list of lease ids.",
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/leases/renew": {
      "description": "Renew a lease on a secret",
      "post": {
        "summary": "Renews a lease, requesting to extend the lease.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LeasesRenewRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/leases/renew/{url_lease_id}": {
      "description": "Renew a lease on a secret",
      "parameters": [
        {
          "name": "url_lease_id",
          "description": "The lease identifier to renew. This is included with a lease.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Renews a lease, requesting to extend the lease.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LeasesRenewLeaseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/leases/revoke": {
      "description": "Revoke a leased secret immediately",
      "post": {
        "summary": "Revokes a lease immediately.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LeasesRevokeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/leases/revoke-force/{prefix}": {
      "description": "Revoke all secrets generated in a given prefix, ignoring errors.",
      "parameters": [
        {
          "name": "prefix",
          "description": "The path to revoke keys under. Example: \"prod/aws/ops\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "post": {
        "summary": "Revokes all secrets or tokens generated under a given prefix immediately",
        "description": "Unlike `/sys/leases/revoke-prefix`, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.\n\nBy ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/leases/revoke-prefix/{prefix}": {
      "description": "Revoke all secrets generated in a given prefix",
      "parameters": [
        {
          "name": "prefix",
          "description": "The path to revoke keys under. Example: \"prod/aws/ops\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "post": {
        "summary": "Revokes all secrets (via a lease ID prefix) or tokens (via the tokens' path property) generated under a given prefix immediately.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LeasesRevokePrefixRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/leases/revoke/{url_lease_id}": {
      "description": "Revoke a leased secret immediately",
      "parameters": [
        {
          "name": "url_lease_id",
          "description": "The lease identifier to renew. This is included with a lease.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Revokes a lease immediately.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LeasesRevokeLeaseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/leases/tidy": {
      "description": "This endpoint performs cleanup tasks that can be run if certain error conditions have occurred.",
      "post": {
        "summary": "This endpoint performs cleanup tasks that can be run if certain error\nconditions have occurred.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/locked-users": {
      "description": "Report the locked user count metrics",
      "get": {
        "summary": "Report the locked user count metrics, for this namespace and all child namespaces.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/locked-users/{mount_accessor}/unlock/{alias_identifier}": {
      "description": "Unlock the locked user with given mount_accessor and alias_identifier.",
      "parameters": [
        {
          "name": "alias_identifier",
          "description": "It is the name of the alias (user). For example, if the alias belongs to userpass backend, the name should be a valid username within userpass auth method. If the alias belongs to an approle auth method, the name should be a valid RoleID",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "mount_accessor",
          "description": "MountAccessor is the identifier of the mount entry to which the user belongs",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Unlocks the user with given mount_accessor and alias_identifier",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/loggers": {
      "get": {
        "summary": "Read the log level for all existing loggers.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Modify the log level for all existing loggers.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LoggersRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Revert the all loggers to use log level provided in config.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/loggers/{name}": {
      "parameters": [
        {
          "name": "name",
          "description": "The name of the logger to be modified.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Read the log level for a single logger.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Modify the log level of a single logger.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LoggersRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Revert a single logger to use log level provided in config.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/metrics": {
      "description": "Export the metrics aggregated for telemetry purpose.",
      "parameters": [
        {
          "name": "format",
          "description": "Format to export metrics into. Currently accepts only \"prometheus\".",
          "in": "query",
          "schema": {
            "type": "string"
          }
        }
      ],
      "get": {
        "summary": "Export the metrics aggregated for telemetry purpose.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/mfa/validate": {
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Validates the login for the given MFA methods. Upon successful validation, it returns an auth response containing the client token",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MfaValidateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/monitor": {
      "parameters": [
        {
          "name": "log_format",
          "description": "Output format of logs. Supported values are \"standard\" and \"json\". The default is \"standard\".",
          "in": "query",
          "schema": {
            "type": "string",
            "default": "standard"
          }
        },
        {
          "name": "log_level",
          "description": "Log level to view system logs at. Currently supported values are \"trace\", \"debug\", \"info\", \"warn\", \"error\".",
          "in": "query",
          "schema": {
            "type": "string"
          }
        }
      ],
      "get": {
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/mounts": {
      "description": "List the currently mounted backends.",
      "get": {
        "summary": "List the currently mounted backends.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/mounts/{path}": {
      "description": "Mount a new backend at a new path.",
      "parameters": [
        {
          "name": "path",
          "description": "The path to mount to. Example: \"aws/east\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Read the configuration of the secret engine at the given path.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Enable a new secrets engine at the given path.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MountsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Disable the mount point specified at the given path.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/mounts/{path}/tune": {
      "description": "Tune backend configuration parameters for this mount.",
      "parameters": [
        {
          "name": "path",
          "description": "The path to mount to. Example: \"aws/east\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Tune backend configuration parameters for this mount.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Tune backend configuration parameters for this mount.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/MountsTuneRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/plugins/catalog": {
      "description": "Lists all the plugins known to Vault",
      "get": {
        "summary": "Lists all the plugins known to Vault",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/plugins/catalog/{name}": {
      "description": "Configures the plugins known to Vault",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the plugin",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Return the configuration data for the plugin with the given name.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Register a new plugin, or updates an existing one with the supplied name.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PluginsCatalogRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Remove the plugin with the given name.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/plugins/catalog/{type}": {
      "description": "Configures the plugins known to Vault",
      "parameters": [
        {
          "name": "type",
          "description": "The type of the plugin, may be auth, secret, or database",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "List the plugins in the catalog.",
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/plugins/catalog/{type}/{name}": {
      "description": "Configures the plugins known to Vault",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the plugin",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        },
        {
          "name": "type",
          "description": "The type of the plugin, may be auth, secret, or database",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "get": {
        "summary": "Return the configuration data for the plugin with the given name.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Register a new plugin, or updates an existing one with the supplied name.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PluginsCatalogRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Remove the plugin with the given name.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/plugins/reload/backend": {
      "description": "Reload mounts that use a particular backend plugin.",
      "post": {
        "summary": "Reload mounted plugin backends.",
        "description": "Either the plugin name (`plugin`) or the desired plugin backend mounts (`mounts`) must be provided, but not both. In the case that the plugin name is provided, all mounted paths that use that plugin backend will be reloaded.  If (`scope`) is provided and is (`global`), the plugin(s) are reloaded globally.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PluginsReloadBackendRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/policies/acl": {
      "description": "List the configured access control policies.",
      "get": {
        "summary": "List the configured access control policies.",
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/policies/acl/{name}": {
      "description": "Read, Modify, or Delete an access control policy.",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the policy. Example: \"ops\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve information about the named ACL policy.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Add a new or update an existing ACL policy.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PoliciesAclRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete the ACL policy with the given name.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/policies/password": {
      "get": {
        "summary": "List the existing password policies.",
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/policies/password/{name}": {
      "description": "Read, Modify, or Delete a password policy.",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the password policy.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve an existing password policy.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Add a new or update an existing password policy.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PoliciesPasswordRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete a password policy.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/policies/password/{name}/generate": {
      "description": "Generate a password from an existing password policy.",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the password policy.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Generate a password from an existing password policy.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/policy": {
      "description": "List the configured access control policies.",
      "get": {
        "summary": "List the configured access control policies.",
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/policy/{name}": {
      "description": "Read, Modify, or Delete an access control policy.",
      "parameters": [
        {
          "name": "name",
          "description": "The name of the policy. Example: \"ops\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Retrieve the policy body for the named policy.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Add a new or update an existing policy.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PolicyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete the policy with the given name.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/pprof/": {
      "get": {
        "summary": "Returns an HTML page listing the available profiles.",
        "description": "Returns an HTML page listing the available \nprofiles. This should be mainly accessed via browsers or applications that can \nrender pages.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/pprof/allocs": {
      "get": {
        "summary": "Returns a sampling of all past memory allocations.",
        "description": "Returns a sampling of all past memory allocations.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/pprof/block": {
      "get": {
        "summary": "Returns stack traces that led to blocking on synchronization primitives",
        "description": "Returns stack traces that led to blocking on synchronization primitives",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/pprof/cmdline": {
      "get": {
        "summary": "Returns the running program's command line.",
        "description": "Returns the running program's command line, with arguments separated by NUL bytes.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/pprof/goroutine": {
      "get": {
        "summary": "Returns stack traces of all current goroutines.",
        "description": "Returns stack traces of all current goroutines.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/pprof/heap": {
      "get": {
        "summary": "Returns a sampling of memory allocations of live object.",
        "description": "Returns a sampling of memory allocations of live object.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/pprof/mutex": {
      "get": {
        "summary": "Returns stack traces of holders of contended mutexes",
        "description": "Returns stack traces of holders of contended mutexes",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/pprof/profile": {
      "get": {
        "summary": "Returns a pprof-formatted cpu profile payload.",
        "description": "Returns a pprof-formatted cpu profile payload. Profiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/pprof/symbol": {
      "get": {
        "summary": "Returns the program counters listed in the request.",
        "description": "Returns the program counters listed in the request.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/pprof/threadcreate": {
      "get": {
        "summary": "Returns stack traces that led to the creation of new OS threads",
        "description": "Returns stack traces that led to the creation of new OS threads",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/pprof/trace": {
      "get": {
        "summary": "Returns the execution trace in binary form.",
        "description": "Returns  the execution trace in binary form. Tracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/quotas/config": {
      "description": "Create, update and read the quota configuration.",
      "get": {
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QuotasConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/quotas/rate-limit": {
      "description": "Lists the names of all the rate limit quotas.",
      "get": {
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/quotas/rate-limit/{name}": {
      "description": "Get, create or update rate limit resource quota for an optional namespace or mount.",
      "parameters": [
        {
          "name": "name",
          "description": "Name of the quota rule.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/QuotasRateLimitRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/raw": {
      "description": "Write, Read, and Delete data directly in the Storage backend.",
      "x-vault-sudo": true,
      "x-vault-createSupported": true,
      "get": {
        "summary": "Read the value of the key at the given path.",
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the value of the key at the given path.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RawRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete the key with given path.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/raw/{path}": {
      "description": "Write, Read, and Delete data directly in the Storage backend.",
      "parameters": [
        {
          "name": "path",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "x-vault-createSupported": true,
      "get": {
        "summary": "Read the value of the key at the given path.",
        "parameters": [
          {
            "name": "list",
            "description": "Return a list if `true`",
            "in": "query",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Update the value of the key at the given path.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RawRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete the key with given path.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/rekey/backup": {
      "description": "Allows fetching or deleting the backup of the rotated unseal keys.",
      "get": {
        "summary": "Return the backup copy of PGP-encrypted unseal keys.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Delete the backup copy of PGP-encrypted unseal keys.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/rekey/init": {
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Reads the configuration and progress of the current rekey attempt.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Initializes a new rekey attempt.",
        "description": "Only a single rekey attempt can take place at a time, and changing the parameters of a rekey requires canceling and starting a new rekey, which will also provide a new nonce.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RekeyInitRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Cancels any in-progress rekey.",
        "description": "This clears the rekey settings as well as any progress made. This must be called to change the parameters of the rekey. Note: verification is still a part of a rekey. If rekeying is canceled during the verification flow, the current unseal keys remain valid.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/rekey/recovery-key-backup": {
      "description": "Allows fetching or deleting the backup of the rotated unseal keys.",
      "get": {
        "summary": "Allows fetching or deleting the backup of the rotated unseal keys.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Allows fetching or deleting the backup of the rotated unseal keys.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/rekey/update": {
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Enter a single unseal key share to progress the rekey of the Vault.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RekeyUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/rekey/verify": {
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Read the configuration and progress of the current rekey verification attempt.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Enter a single new key share to progress the rekey verification operation.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RekeyVerifyRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "delete": {
        "summary": "Cancel any in-progress rekey verification operation.",
        "description": "This clears any progress made and resets the nonce. Unlike a `DELETE` against `sys/rekey/init`, this only resets the current verification operation, not the entire rekey atttempt.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/remount": {
      "description": "Move the mount point of an already-mounted backend, within or across namespaces",
      "x-vault-sudo": true,
      "post": {
        "summary": "Initiate a mount migration",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RemountRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/remount/status/{migration_id}": {
      "description": "Check the status of a mount move operation",
      "parameters": [
        {
          "name": "migration_id",
          "description": "The ID of the migration operation",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "get": {
        "summary": "Check status of a mount migration",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/renew": {
      "description": "Renew a lease on a secret",
      "post": {
        "summary": "Renews a lease, requesting to extend the lease.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RenewRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/renew/{url_lease_id}": {
      "description": "Renew a lease on a secret",
      "parameters": [
        {
          "name": "url_lease_id",
          "description": "The lease identifier to renew. This is included with a lease.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Renews a lease, requesting to extend the lease.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RenewLeaseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/replication/status": {
      "x-vault-unauthenticated": true,
      "get": {
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/revoke": {
      "description": "Revoke a leased secret immediately",
      "post": {
        "summary": "Revokes a lease immediately.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RevokeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/revoke-force/{prefix}": {
      "description": "Revoke all secrets generated in a given prefix, ignoring errors.",
      "parameters": [
        {
          "name": "prefix",
          "description": "The path to revoke keys under. Example: \"prod/aws/ops\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "post": {
        "summary": "Revokes all secrets or tokens generated under a given prefix immediately",
        "description": "Unlike `/sys/leases/revoke-prefix`, this path ignores backend errors encountered during revocation. This is potentially very dangerous and should only be used in specific emergency situations where errors in the backend or the connected backend service prevent normal revocation.\n\nBy ignoring these errors, Vault abdicates responsibility for ensuring that the issued credentials or secrets are properly revoked and/or cleaned up. Access to this endpoint should be tightly controlled.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/revoke-prefix/{prefix}": {
      "description": "Revoke all secrets generated in a given prefix",
      "parameters": [
        {
          "name": "prefix",
          "description": "The path to revoke keys under. Example: \"prod/aws/ops\"",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "x-vault-sudo": true,
      "post": {
        "summary": "Revokes all secrets (via a lease ID prefix) or tokens (via the tokens' path property) generated under a given prefix immediately.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RevokePrefixRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/revoke/{url_lease_id}": {
      "description": "Revoke a leased secret immediately",
      "parameters": [
        {
          "name": "url_lease_id",
          "description": "The lease identifier to renew. This is included with a lease.",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Revokes a lease immediately.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RevokeLeaseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/rotate": {
      "description": "Rotates the backend encryption key used to persist data.",
      "x-vault-sudo": true,
      "post": {
        "summary": "Rotates the backend encryption key used to persist data.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/rotate/config": {
      "description": "Configures settings related to the backend encryption key management.",
      "get": {
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RotateConfigRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/seal": {
      "description": "Seals the Vault.",
      "post": {
        "summary": "Seal the Vault.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/seal-status": {
      "description": "Returns the seal status of the Vault.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Check the seal status of a Vault.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/step-down": {
      "post": {
        "summary": "Cause the node to give up active status.",
        "description": "This endpoint forces the node to give up active status. If the node does not have active status, this endpoint does nothing. Note that the node will sleep for ten seconds before attempting to grab the active lock again, but if no standby nodes grab the active lock in the interim, the same node may become the active node again.",
        "responses": {
          "204": {
            "description": "empty body"
          }
        }
      }
    },
    "/tools/hash": {
      "description": "Generate a hash sum for input data",
      "post": {
        "summary": "Generate a hash sum for input data",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ToolsHashRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/tools/hash/{urlalgorithm}": {
      "description": "Generate a hash sum for input data",
      "parameters": [
        {
          "name": "urlalgorithm",
          "description": "Algorithm to use (POST URL parameter)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Generate a hash sum for input data",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ToolsHashRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/tools/random": {
      "description": "Generate random bytes",
      "post": {
        "summary": "Generate random bytes",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ToolsRandomRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/tools/random/{source}": {
      "description": "Generate random bytes",
      "parameters": [
        {
          "name": "source",
          "description": "Which system to source random data from, ether \"platform\", \"seal\", or \"all\".",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "platform"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Generate random bytes",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ToolsRandomRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/tools/random/{source}/{urlbytes}": {
      "description": "Generate random bytes",
      "parameters": [
        {
          "name": "source",
          "description": "Which system to source random data from, ether \"platform\", \"seal\", or \"all\".",
          "in": "path",
          "schema": {
            "type": "string",
            "default": "platform"
          },
          "required": true
        },
        {
          "name": "urlbytes",
          "description": "The number of bytes to generate (POST URL parameter)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Generate random bytes",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ToolsRandomRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/tools/random/{urlbytes}": {
      "description": "Generate random bytes",
      "parameters": [
        {
          "name": "urlbytes",
          "description": "The number of bytes to generate (POST URL parameter)",
          "in": "path",
          "schema": {
            "type": "string"
          },
          "required": true
        }
      ],
      "post": {
        "summary": "Generate random bytes",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ToolsRandomRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/unseal": {
      "description": "Unseals the Vault.",
      "x-vault-unauthenticated": true,
      "post": {
        "summary": "Unseal the Vault.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UnsealRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/version-history/": {
      "description": "List historical version changes sorted by installation time in ascending order.",
      "get": {
        "summary": "Returns map of historical version change entries",
        "parameters": [
          {
            "name": "list",
            "description": "Must be set to `true`",
            "in": "query",
            "schema": {
              "type": "string",
              "enum": [
                "true"
              ]
            },
            "required": true
          }
        ],
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/wrapping/lookup": {
      "description": "Looks up the properties of a response-wrapped token.",
      "x-vault-unauthenticated": true,
      "get": {
        "summary": "Look up wrapping properties for the requester's token.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      },
      "post": {
        "summary": "Look up wrapping properties for the given token.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WrappingLookupRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/wrapping/rewrap": {
      "description": "Rotates a response-wrapped token.",
      "post": {
        "summary": "Rotates a response-wrapped token.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WrappingRewrapRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/wrapping/unwrap": {
      "description": "Unwraps a response-wrapped token.",
      "post": {
        "summary": "Unwraps a response-wrapped token.",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WrappingUnwrapRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    },
    "/wrapping/wrap": {
      "description": "Response-wraps an arbitrary JSON object.",
      "post": {
        "summary": "Response-wraps an arbitrary JSON object.",
        "responses": {
          "200": {
            "description": "OK"
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AuditHashRequest": {
        "type": "object",
        "properties": {
          "input": {
            "type": "string"
          }
        }
      },
      "AuditHashResponse": {
        "type": "object",
        "properties": {
          "hash": {
            "type": "string"
          }
        }
      },
      "AuditRequest": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string",
            "description": "User-friendly description for this audit backend."
          },
          "local": {
            "type": "boolean",
            "description": "Mark the mount as a local mount, which is not replicated and is unaffected by replication.",
            "default": false
          },
          "options": {
            "type": "object",
            "description": "Configuration options for the audit backend.",
            "format": "kvpairs"
          },
          "type": {
            "type": "string",
            "description": "The type of the backend. Example: \"mysql\""
          }
        }
      },
      "AuthRequest": {
        "type": "object",
        "properties": {
          "config": {
            "type": "object",
            "description": "Configuration for this mount, such as plugin_name.",
            "format": "map"
          },
          "description": {
            "type": "string",
            "description": "User-friendly description for this credential backend."
          },
          "external_entropy_access": {
            "type": "boolean",
            "description": "Whether to give the mount access to Vault's external entropy.",
            "default": false
          },
          "local": {
            "type": "boolean",
            "description": "Mark the mount as a local mount, which is not replicated and is unaffected by replication.",
            "default": false
          },
          "options": {
            "type": "object",
            "description": "The options to pass into the backend. Should be a json object with string keys and values.",
            "format": "kvpairs"
          },
          "plugin_name": {
            "type": "string",
            "description": "Name of the auth plugin to use based from the name in the plugin catalog."
          },
          "plugin_version": {
            "type": "string",
            "description": "The semantic version of the plugin to use."
          },
          "seal_wrap": {
            "type": "boolean",
            "description": "Whether to turn on seal wrapping for the mount.",
            "default": false
          },
          "type": {
            "type": "string",
            "description": "The type of the backend. Example: \"userpass\""
          }
        }
      },
      "AuthTuneRequest": {
        "type": "object",
        "properties": {
          "allowed_response_headers": {
            "type": "array",
            "description": "A list of headers to whitelist and allow a plugin to set on responses.",
            "items": {
              "type": "string"
            }
          },
          "audit_non_hmac_request_keys": {
            "type": "array",
            "description": "The list of keys in the request data object that will not be HMAC'ed by audit devices.",
            "items": {
              "type": "string"
            }
          },
          "audit_non_hmac_response_keys": {
            "type": "array",
            "description": "The list of keys in the response data object that will not be HMAC'ed by audit devices.",
            "items": {
              "type": "string"
            }
          },
          "default_lease_ttl": {
            "type": "string",
            "description": "The default lease TTL for this mount."
          },
          "description": {
            "type": "string",
            "description": "User-friendly description for this credential backend."
          },
          "listing_visibility": {
            "type": "string",
            "description": "Determines the visibility of the mount in the UI-specific listing endpoint. Accepted value are 'unauth' and 'hidden', with the empty default ('') behaving like 'hidden'."
          },
          "max_lease_ttl": {
            "type": "string",
            "description": "The max lease TTL for this mount."
          },
          "options": {
            "type": "object",
            "description": "The options to pass into the backend. Should be a json object with string keys and values.",
            "format": "kvpairs"
          },
          "passthrough_request_headers": {
            "type": "array",
            "description": "A list of headers to whitelist and pass from the request to the plugin.",
            "items": {
              "type": "string"
            }
          },
          "plugin_version": {
            "type": "string",
            "description": "The semantic version of the plugin to use."
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to issue (service or batch)."
          },
          "user_lockout_config": {
            "type": "object",
            "description": "The user lockout configuration to pass into the backend. Should be a json object with string keys and values.",
            "format": "map"
          }
        }
      },
      "CapabilitiesAccessorRequest": {
        "type": "object",
        "properties": {
          "accessor": {
            "type": "string",
            "description": "Accessor of the token for which capabilities are being queried."
          },
          "path": {
            "type": "array",
            "description": "Use 'paths' instead.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "paths": {
            "type": "array",
            "description": "Paths on which capabilities are being queried.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "CapabilitiesRequest": {
        "type": "object",
        "properties": {
          "path": {
            "type": "array",
            "description": "Use 'paths' instead.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "paths": {
            "type": "array",
            "description": "Paths on which capabilities are being queried.",
            "items": {
              "type": "string"
            }
          },
          "token": {
            "type": "string",
            "description": "Token for which capabilities are being queried."
          }
        }
      },
      "CapabilitiesSelfRequest": {
        "type": "object",
        "properties": {
          "path": {
            "type": "array",
            "description": "Use 'paths' instead.",
            "items": {
              "type": "string"
            },
            "deprecated": true
          },
          "paths": {
            "type": "array",
            "description": "Paths on which capabilities are being queried.",
            "items": {
              "type": "string"
            }
          },
          "token": {
            "type": "string",
            "description": "Token for which capabilities are being queried."
          }
        }
      },
      "ConfigAuditingRequestHeadersRequest": {
        "type": "object",
        "properties": {
          "hmac": {
            "type": "boolean"
          }
        }
      },
      "ConfigAuditingRequestHeadersResponse": {
        "type": "object",
        "properties": {
          "headers": {
            "type": "object",
            "format": "map"
          }
        }
      },
      "ConfigCorsRequest": {
        "type": "object",
        "properties": {
          "allowed_headers": {
            "type": "array",
            "description": "A comma-separated string or array of strings indicating headers that are allowed on cross-origin requests.",
            "items": {
              "type": "string"
            }
          },
          "allowed_origins": {
            "type": "array",
            "description": "A comma-separated string or array of strings indicating origins that may make cross-origin requests.",
            "items": {
              "type": "string"
            }
          },
          "enable": {
            "type": "boolean",
            "description": "Enables or disables CORS headers on requests."
          }
        }
      },
      "ConfigUiHeadersRequest": {
        "type": "object",
        "properties": {
          "multivalue": {
            "type": "boolean",
            "description": "Returns multiple values if true"
          },
          "values": {
            "type": "array",
            "description": "The values to set the header.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "GenerateRootAttemptRequest": {
        "type": "object",
        "properties": {
          "pgp_key": {
            "type": "string",
            "description": "Specifies a base64-encoded PGP public key."
          }
        }
      },
      "GenerateRootRequest": {
        "type": "object",
        "properties": {
          "pgp_key": {
            "type": "string",
            "description": "Specifies a base64-encoded PGP public key."
          }
        }
      },
      "GenerateRootUpdateRequest": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "Specifies a single unseal key share."
          },
          "nonce": {
            "type": "string",
            "description": "Specifies the nonce of the attempt."
          }
        }
      },
      "InitRequest": {
        "type": "object",
        "properties": {
          "pgp_keys": {
            "type": "array",
            "description": "Specifies an array of PGP public keys used to encrypt the output unseal keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as `secret_shares`.",
            "items": {
              "type": "string"
            }
          },
          "recovery_pgp_keys": {
            "type": "array",
            "description": "Specifies an array of PGP public keys used to encrypt the output recovery keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as `recovery_shares`.",
            "items": {
              "type": "string"
            }
          },
          "recovery_shares": {
            "type": "integer",
            "description": "Specifies the number of shares to split the recovery key into."
          },
          "recovery_threshold": {
            "type": "integer",
            "description": "Specifies the number of shares required to reconstruct the recovery key. This must be less than or equal to `recovery_shares`."
          },
          "root_token_pgp_key": {
            "type": "string",
            "description": "Specifies a PGP public key used to encrypt the initial root token. The key must be base64-encoded from its original binary representation."
          },
          "secret_shares": {
            "type": "integer",
            "description": "Specifies the number of shares to split the unseal key into."
          },
          "secret_threshold": {
            "type": "integer",
            "description": "Specifies the number of shares required to reconstruct the unseal key. This must be less than or equal secret_shares. If using Vault HSM with auto-unsealing, this value must be the same as `secret_shares`."
          },
          "stored_shares": {
            "type": "integer",
            "description": "Specifies the number of shares that should be encrypted by the HSM and stored for auto-unsealing. Currently must be the same as `secret_shares`."
          }
        }
      },
      "InternalCountersConfigRequest": {
        "type": "object",
        "properties": {
          "default_report_months": {
            "type": "integer",
            "description": "Number of months to report if no start date specified.",
            "default": 12
          },
          "enabled": {
            "type": "string",
            "description": "Enable or disable collection of client count: enable, disable, or default.",
            "default": "default"
          },
          "retention_months": {
            "type": "integer",
            "description": "Number of months of client data to retain. Setting to 0 will clear all existing data.",
            "default": 24
          }
        }
      },
      "InternalSpecsOpenapiRequest": {
        "type": "object",
        "properties": {
          "context": {
            "type": "string",
            "description": "Context string appended to every operationId"
          }
        }
      },
      "LeasesLookupRequest": {
        "type": "object",
        "properties": {
          "lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          }
        }
      },
      "LeasesRenewLeaseRequest": {
        "type": "object",
        "properties": {
          "increment": {
            "type": "integer",
            "description": "The desired increment in seconds to the lease",
            "format": "seconds"
          },
          "lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          }
        }
      },
      "LeasesRenewRequest": {
        "type": "object",
        "properties": {
          "increment": {
            "type": "integer",
            "description": "The desired increment in seconds to the lease",
            "format": "seconds"
          },
          "lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          },
          "url_lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          }
        }
      },
      "LeasesRevokeLeaseRequest": {
        "type": "object",
        "properties": {
          "lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          },
          "sync": {
            "type": "boolean",
            "description": "Whether or not to perform the revocation synchronously",
            "default": true
          }
        }
      },
      "LeasesRevokePrefixRequest": {
        "type": "object",
        "properties": {
          "sync": {
            "type": "boolean",
            "description": "Whether or not to perform the revocation synchronously",
            "default": true
          }
        }
      },
      "LeasesRevokeRequest": {
        "type": "object",
        "properties": {
          "lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          },
          "sync": {
            "type": "boolean",
            "description": "Whether or not to perform the revocation synchronously",
            "default": true
          },
          "url_lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          }
        }
      },
      "LoggersRequest": {
        "type": "object",
        "properties": {
          "level": {
            "type": "string",
            "description": "Log verbosity level. Supported values (in order of detail) are \"trace\", \"debug\", \"info\", \"warn\", and \"error\"."
          }
        }
      },
      "MfaValidateRequest": {
        "type": "object",
        "properties": {
          "mfa_payload": {
            "type": "object",
            "description": "A map from MFA method ID to a slice of passcodes or an empty slice if the method does not use passcodes",
            "format": "map"
          },
          "mfa_request_id": {
            "type": "string",
            "description": "ID for this MFA request"
          }
        },
        "required": [
          "mfa_payload",
          "mfa_request_id"
        ]
      },
      "MountsRequest": {
        "type": "object",
        "properties": {
          "config": {
            "type": "object",
            "description": "Configuration for this mount, such as default_lease_ttl and max_lease_ttl.",
            "format": "map"
          },
          "description": {
            "type": "string",
            "description": "User-friendly description for this mount."
          },
          "external_entropy_access": {
            "type": "boolean",
            "description": "Whether to give the mount access to Vault's external entropy.",
            "default": false
          },
          "local": {
            "type": "boolean",
            "description": "Mark the mount as a local mount, which is not replicated and is unaffected by replication.",
            "default": false
          },
          "options": {
            "type": "object",
            "description": "The options to pass into the backend. Should be a json object with string keys and values.",
            "format": "kvpairs"
          },
          "plugin_name": {
            "type": "string",
            "description": "Name of the plugin to mount based from the name registered in the plugin catalog."
          },
          "plugin_version": {
            "type": "string",
            "description": "The semantic version of the plugin to use."
          },
          "seal_wrap": {
            "type": "boolean",
            "description": "Whether to turn on seal wrapping for the mount.",
            "default": false
          },
          "type": {
            "type": "string",
            "description": "The type of the backend. Example: \"passthrough\""
          }
        }
      },
      "MountsTuneRequest": {
        "type": "object",
        "properties": {
          "allowed_managed_keys": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "allowed_response_headers": {
            "type": "array",
            "description": "A list of headers to whitelist and allow a plugin to set on responses.",
            "items": {
              "type": "string"
            }
          },
          "audit_non_hmac_request_keys": {
            "type": "array",
            "description": "The list of keys in the request data object that will not be HMAC'ed by audit devices.",
            "items": {
              "type": "string"
            }
          },
          "audit_non_hmac_response_keys": {
            "type": "array",
            "description": "The list of keys in the response data object that will not be HMAC'ed by audit devices.",
            "items": {
              "type": "string"
            }
          },
          "default_lease_ttl": {
            "type": "string",
            "description": "The default lease TTL for this mount."
          },
          "description": {
            "type": "string",
            "description": "User-friendly description for this credential backend."
          },
          "listing_visibility": {
            "type": "string",
            "description": "Determines the visibility of the mount in the UI-specific listing endpoint. Accepted value are 'unauth' and 'hidden', with the empty default ('') behaving like 'hidden'."
          },
          "max_lease_ttl": {
            "type": "string",
            "description": "The max lease TTL for this mount."
          },
          "options": {
            "type": "object",
            "description": "The options to pass into the backend. Should be a json object with string keys and values.",
            "format": "kvpairs"
          },
          "passthrough_request_headers": {
            "type": "array",
            "description": "A list of headers to whitelist and pass from the request to the plugin.",
            "items": {
              "type": "string"
            }
          },
          "plugin_version": {
            "type": "string",
            "description": "The semantic version of the plugin to use."
          },
          "token_type": {
            "type": "string",
            "description": "The type of token to issue (service or batch)."
          },
          "user_lockout_config": {
            "type": "object",
            "description": "The user lockout configuration to pass into the backend. Should be a json object with string keys and values.",
            "format": "map"
          }
        }
      },
      "PluginsCatalogRequest": {
        "type": "object",
        "properties": {
          "args": {
            "type": "array",
            "description": "The args passed to plugin command.",
            "items": {
              "type": "string"
            }
          },
          "command": {
            "type": "string",
            "description": "The command used to start the plugin. The executable defined in this command must exist in vault's plugin directory."
          },
          "env": {
            "type": "array",
            "description": "The environment variables passed to plugin command. Each entry is of the form \"key=value\".",
            "items": {
              "type": "string"
            }
          },
          "sha256": {
            "type": "string",
            "description": "The SHA256 sum of the executable used in the command field. This should be HEX encoded."
          },
          "version": {
            "type": "string",
            "description": "The semantic version of the plugin to use."
          }
        }
      },
      "PluginsReloadBackendRequest": {
        "type": "object",
        "properties": {
          "mounts": {
            "type": "array",
            "description": "The mount paths of the plugin backends to reload.",
            "items": {
              "type": "string"
            }
          },
          "plugin": {
            "type": "string",
            "description": "The name of the plugin to reload, as registered in the plugin catalog."
          },
          "scope": {
            "type": "string"
          }
        }
      },
      "PoliciesAclRequest": {
        "type": "object",
        "properties": {
          "policy": {
            "type": "string",
            "description": "The rules of the policy."
          }
        }
      },
      "PoliciesPasswordRequest": {
        "type": "object",
        "properties": {
          "policy": {
            "type": "string",
            "description": "The password policy"
          }
        }
      },
      "PolicyRequest": {
        "type": "object",
        "properties": {
          "policy": {
            "type": "string",
            "description": "The rules of the policy."
          },
          "rules": {
            "type": "string",
            "description": "The rules of the policy.",
            "deprecated": true
          }
        }
      },
      "QuotasConfigRequest": {
        "type": "object",
        "properties": {
          "enable_rate_limit_audit_logging": {
            "type": "boolean",
            "description": "If set, starts audit logging of requests that get rejected due to rate limit quota rule violations."
          },
          "enable_rate_limit_response_headers": {
            "type": "boolean",
            "description": "If set, additional rate limit quota HTTP headers will be added to responses."
          },
          "rate_limit_exempt_paths": {
            "type": "array",
            "description": "Specifies the list of exempt paths from all rate limit quotas. If empty no paths will be exempt.",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "QuotasRateLimitRequest": {
        "type": "object",
        "properties": {
          "block_interval": {
            "type": "integer",
            "description": "If set, when a client reaches a rate limit threshold, the client will be prohibited from any further requests until after the 'block_interval' has elapsed.",
            "format": "seconds"
          },
          "interval": {
            "type": "integer",
            "description": "The duration to enforce rate limiting for (default '1s').",
            "format": "seconds"
          },
          "path": {
            "type": "string",
            "description": "Path of the mount or namespace to apply the quota. A blank path configures a global quota. For example namespace1/ adds a quota to a full namespace, namespace1/auth/userpass adds a quota to userpass in namespace1."
          },
          "rate": {
            "type": "number",
            "description": "The maximum number of requests in a given interval to be allowed by the quota rule. The 'rate' must be positive.",
            "format": "float"
          },
          "role": {
            "type": "string",
            "description": "Login role to apply this quota to. Note that when set, path must be configured to a valid auth method with a concept of roles."
          },
          "type": {
            "type": "string",
            "description": "Type of the quota rule."
          }
        }
      },
      "RawRequest": {
        "type": "object",
        "properties": {
          "compressed": {
            "type": "boolean"
          },
          "compression_type": {
            "type": "string"
          },
          "encoding": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        }
      },
      "RekeyInitRequest": {
        "type": "object",
        "properties": {
          "backup": {
            "type": "boolean",
            "description": "Specifies if using PGP-encrypted keys, whether Vault should also store a plaintext backup of the PGP-encrypted keys."
          },
          "pgp_keys": {
            "type": "array",
            "description": "Specifies an array of PGP public keys used to encrypt the output unseal keys. Ordering is preserved. The keys must be base64-encoded from their original binary representation. The size of this array must be the same as secret_shares.",
            "items": {
              "type": "string"
            }
          },
          "require_verification": {
            "type": "boolean",
            "description": "Turns on verification functionality"
          },
          "secret_shares": {
            "type": "integer",
            "description": "Specifies the number of shares to split the unseal key into."
          },
          "secret_threshold": {
            "type": "integer",
            "description": "Specifies the number of shares required to reconstruct the unseal key. This must be less than or equal secret_shares. If using Vault HSM with auto-unsealing, this value must be the same as secret_shares."
          }
        }
      },
      "RekeyUpdateRequest": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "Specifies a single unseal key share."
          },
          "nonce": {
            "type": "string",
            "description": "Specifies the nonce of the rekey attempt."
          }
        }
      },
      "RekeyVerifyRequest": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "Specifies a single unseal share key from the new set of shares."
          },
          "nonce": {
            "type": "string",
            "description": "Specifies the nonce of the rekey verification operation."
          }
        }
      },
      "RemountRequest": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "description": "The previous mount point."
          },
          "to": {
            "type": "string",
            "description": "The new mount point."
          }
        }
      },
      "RenewLeaseRequest": {
        "type": "object",
        "properties": {
          "increment": {
            "type": "integer",
            "description": "The desired increment in seconds to the lease",
            "format": "seconds"
          },
          "lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          }
        }
      },
      "RenewRequest": {
        "type": "object",
        "properties": {
          "increment": {
            "type": "integer",
            "description": "The desired increment in seconds to the lease",
            "format": "seconds"
          },
          "lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          },
          "url_lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          }
        }
      },
      "RevokeLeaseRequest": {
        "type": "object",
        "properties": {
          "lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          },
          "sync": {
            "type": "boolean",
            "description": "Whether or not to perform the revocation synchronously",
            "default": true
          }
        }
      },
      "RevokePrefixRequest": {
        "type": "object",
        "properties": {
          "sync": {
            "type": "boolean",
            "description": "Whether or not to perform the revocation synchronously",
            "default": true
          }
        }
      },
      "RevokeRequest": {
        "type": "object",
        "properties": {
          "lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          },
          "sync": {
            "type": "boolean",
            "description": "Whether or not to perform the revocation synchronously",
            "default": true
          },
          "url_lease_id": {
            "type": "string",
            "description": "The lease identifier to renew. This is included with a lease."
          }
        }
      },
      "RotateConfigRequest": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean",
            "description": "Whether automatic rotation is enabled."
          },
          "interval": {
            "type": "integer",
            "description": "How long after installation of an active key term that the key will be automatically rotated.",
            "format": "seconds"
          },
          "max_operations": {
            "type": "integer",
            "description": "The number of encryption operations performed before the barrier key is automatically rotated.",
            "format": "int64"
          }
        }
      },
      "ToolsHashRequest": {
        "type": "object",
        "properties": {
          "algorithm": {
            "type": "string",
            "description": "Algorithm to use (POST body parameter). Valid values are: * sha2-224 * sha2-256 * sha2-384 * sha2-512 Defaults to \"sha2-256\".",
            "default": "sha2-256"
          },
          "format": {
            "type": "string",
            "description": "Encoding format to use. Can be \"hex\" or \"base64\". Defaults to \"hex\".",
            "default": "hex"
          },
          "input": {
            "type": "string",
            "description": "The base64-encoded input data"
          }
        }
      },
      "ToolsRandomRequest": {
        "type": "object",
        "properties": {
          "bytes": {
            "type": "integer",
            "description": "The number of bytes to generate (POST body parameter). Defaults to 32 (256 bits).",
            "default": 32
          },
          "format": {
            "type": "string",
            "description": "Encoding format to use. Can be \"hex\" or \"base64\". Defaults to \"base64\".",
            "default": "base64"
          }
        }
      },
      "UnsealRequest": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "description": "Specifies a single unseal key share. This is required unless reset is true."
          },
          "reset": {
            "type": "boolean",
            "description": "Specifies if previously-provided unseal keys are discarded and the unseal process is reset."
          }
        }
      },
      "WrappingLookupRequest": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string"
          }
        }
      },
      "WrappingRewrapRequest": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string"
          }
        }
      },
      "WrappingUnwrapRequest": {
        "type": "object",
        "properties": {
          "token": {
            "type": "string"
          }
        }
      }
    }
  }
}
